# 16 Go内存分配和垃圾回收机制

https://www.topgoer.cn/docs/gozhuanjia/gozhuanjiachapter044.1-memory_alloc

https://zhuanlan.zhihu.com/p/518984548

从Go v1.12版本开始，Go使用了**非分代的、并发的、基于三色标记清除的垃圾回收器**。

## Go 内存管理

这里先简单介绍一下 Golang 运行调度。在 Golang 里面有三个基本的概念：G, M, P。

- G: Goroutine 执行的上下文环境。
- M: 操作系统线程。
- P: Processer。进程调度的关键，调度器，也可以认为约等于CPU。

一个 Goroutine 的运行需要G+P+M三部分结合起来。

![v2-6385e751232a3e75db84ff5ecdfd5551_720w](../../Typora picture/v2-6385e751232a3e75db84ff5ecdfd5551_720w.webp)

### **（一）TCMalloc**

Go将内存划分和分组为页（Page），这和Java的内存结构完全不同，没有分代内存，这样的原因是Go的内存分配器采用了TCMalloc的设计思想：

#### **1.Page**

与TCMalloc中的Page相同，x64下1个Page的大小是8KB。上图的最下方，1个浅蓝色的长方形代表1个Page。

#### **2.Span**

与TCMalloc中的Span相同，Span是内存管理的基本单位，代码中为mspan，一组连续的Page组成1个Span，所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span，另外，1个淡紫色长方形为1个Span。

#### **3.mcache**

mcache是提供给P（逻辑处理器）的高速缓存，用于存储小对象（对象大小<= 32Kb）。尽管这类似于线程堆栈，但它是堆的一部分，用于动态数据。所有类大小的mcache包含scan和noscan类型mspan。Goroutine可以从mcache没有任何锁的情况下获取内存，因为一次P只能有一个锁G。因此，这更有效。mcache从mcentral需要时请求新的span。

#### **4.mcentral**

mcentral与TCMalloc中的CentralCache类似，是所有线程共享的缓存，需要加锁访问，它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。每个mcentral包含两个mspanList：

- empty：双向span链表，包括没有空闲对象的span或缓存mcache中的span。当此处的span被释放时，它将被移至non-empty span链表。
- non-empty：有空闲对象的span双向链表。当从mcentral请求新的span，mcentral将从该链表中获取span并将其移入empty span链表。

#### **5.mheap**

mheap与TCMalloc中的PageHeap类似，它是堆内存的抽象，也是垃圾回收的重点区域，把从OS申请出的内存页组织成Span，并保存起来。当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。

#### **6.栈**

这是栈存储区，每个Goroutine（G）有一个栈。在这里存储了静态数据，包括函数栈帧，静态结构，原生类型值和指向动态结构的指针。这与分配给每个P的mcache不是一回事。

## **（二）内存分配**

Go 中的内存分类并不像TCMalloc那样分成小、中、大对象，但是它的小对象里又细分了一个Tiny对象，Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。小对象和大对象只用大小划定，无其他区分。

**核心思想**：把内存分为多级管理，降低锁的粒度(只是去mcentral和mheap会申请锁), 以及多种对象大小类型，减少分配产生的内存碎片。

- ==微小对象(Tiny)（size<16B）==

使用mcache的微小分配器分配小于16个字节的对象，并且在单个16字节块上可完成多个微小分配。

- ==小对象（尺寸16B〜32KB）==

大小在16个字节和32k字节之间的对象被分配在G运行所在的P的mcache的对应的mspan size class上。

- ==大对象（大小>32KB）==

大于32 KB的对象直接分配在mheap的相应大小类上(size class)。

- 如果mheap为空或没有足够大的页面满足分配请求，则它将从操作系统中分配一组新的页（至少1MB）。
- 如果对应的大小规格在mcache中没有可用的块，则向mcentral申请。
- 如果mcentral中没有可用的块，则向mheap申请，并根据BestFit 算法找到最合适的mspan。如果申请到的mspan超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的mspan放回mheap的空闲列表。
- 如果mheap中没有可用span，则向操作系统申请一系列新的页（最小 1MB）。Go 会在操作系统分配超大的页（称作arena）。分配一大批页会减少和操作系统通信的成本。

## **（三）内存回收**

go内存会分成==堆区（Heap）==和==栈区（Stack）==两个部分，==程序在运行期间可以主动从堆区申请内存空间==，这些==内存由内存分配器分配并由垃圾收集器负责回收==。栈区的内存由编译器自动进行分配和释放，==栈区中存储着函数的参数以及局部变量==，它们==会随着函数的创建而创建，函数的返回而销毁==。如果只申请和分配内存，内存终将枯竭。==Go使用垃圾回收收集不再使用的span，把span释放交给mheap，mheap对span进行span的合并，把合并后的span加入scav树中，等待再分配内存时，由mheap进行内存再分配==。**因此，Go堆是Go垃圾收集器管理的主要区域**。

## Golang GC 发展历史

v1.0 — 完全串行的标记和清除过程，需要暂停整个程序；

v1.1 — 在多核主机并行执行垃圾收集的标记和清除阶段；

v1.3 — 运行时**基于只有指针类型的值包含指针**的假设增加了对栈内存的精确扫描支持，实现了真正精确的垃圾收集；将unsafe.Pointer类型转换成整数类型的值认定为不合法的，可能会造成悬挂指针等严重问题；

v1.5 — 实现了基于**三色标记清扫的并发**垃圾收集器：

- 大幅度降低垃圾收集的延迟从几百 ms 降低至 10ms 以下；
- 计算垃圾收集启动的合适时间并通过并发加速垃圾收集的过程；

v1.6 — 实现了去中心化的垃圾收集协调器：

- 基于显式的状态机使得任意Goroutine都能触发垃圾收集的状态迁移；
- 使用密集的位图替代空闲链表表示的堆内存，降低清除阶段的CPU占用;

v1.7 — 通过**并行栈收缩**将垃圾收集的时间缩短至2ms以内；

v1.8 — 使用**混合写屏障**将垃圾收集的时间缩短至0.5ms以内；

v1.9 — 彻底移除暂停程序的重新扫描栈的过程；

v1.10 — 更新了垃圾收集调频器（Pacer）的实现，分离软硬堆大小的目标；

v1.12 — 使用**新的标记终止算法**简化垃圾收集器的几个阶段；

v1.13 — 通过新的 Scavenger 解决瞬时内存占用过高的应用程序向操作系统归还内存的问题；

v1.14 — 使用全新的页分配器**优化内存分配的速度**；

v1.15 — 改进编译器和运行时内部的CL 226367，它使编译器可以将更多的x86寄存器用于垃圾收集器的写屏障调用；

v1.16 — Go runtime默认使用MADV_DONTNEED更积极的将不用的内存释放给OS。

## 垃圾回收机制

程序创建对象等引用类型实体时会在虚拟内存中分配给它们一块内存空间，如果该内存空间不再被任何引用变量引用时就成为需要被回收的垃圾。操作系统会记录一个进程运行时的所占用的内存、CPU和寄存器等资源，当进程结束后便由操作系统能够自动回收资源。但是对于一个运行较长时间的程序，如果使用完内存资源后没有及时释放就会造成内存泄漏甚至系统错误。

如果由于异常或者其他原因导致某个函数运行结束后没有释放其内存，且该函数被频繁调用，那么很容易占用所有系统内存从而导致程序崩溃，如果泄漏的是系统资源的话甚至还会导致系统崩溃。另一方面如果我们在不该释放内存的时候释放内存，那么仍然在使用这块内存的指针就会变成野指针`wild pointer`，使用该指针对内存进行读写是未定义的行为。

### 1. 垃圾回收过程

用户程序`Mutator`通过内存分配器`Allocator`在堆`Heap`上申请内存，垃圾回收器`Collector`会定时清理堆上的内存。内存分配器如何申请内存我们已经在前面`Golang`内存管理介绍过了，本篇主要介绍的是垃圾回收器如何清理内存。

![image-20230619213210848](E:\Typora picture\image-20230619213210848.png)

### 2. 自动垃圾回收与手动垃圾回收

`C`语言这种较为传统的语言通过`malloc`和`free`手动向操作系统申请和释放内存，这种自由管理内存的方式给予程序员极大的自由度，但是也相应地提高了对程序员的要求。`C`语言的内存分配和回收方式主要包括三种：

- 函数体内的局部变量：在栈上创建，函数作用域结束后自动释放内存
- 静态变量：在静态存储区域上分配内存，整个程序运行结束后释放（全局生命周期）
- 动态分配内存的变量：在堆上分配，通过`malloc`申请，`free`释放

`C`、`C++`和`Rust`等较早的语言采用的是手动垃圾回收，需要程序员通过向操作系统申请和释放内存来手动管理内存，程序员极容易忘记释放自己申请的内存，对于一个长期运行的程序往往是一个致命的缺点。`Python`、`Java`和`Golang`等较新的语言==采取的都是自动垃圾回收方式==，程序员只需要负责申请内存，垃圾回收器会周期性释放结束生命周期的变量所占用的内存空间。

### 3. 垃圾回收目标

垃圾回收器主要包括三个目标：

- 无内存泄漏：垃圾回收器最基本的目标就是减少防止程序员未及时释放导致的内存泄漏，垃圾回收器会识别并清理内存中的垃圾
- 自动回收无用内存：垃圾回收器作为独立的子任务，不需要程序员显式调用即可自动清理内存垃圾
- 内存整理：如果只是简单回收无用内存，那么堆上的内存空间会存在较多碎片而无法满足分配较大对象的需求，因此垃圾回收器需要重整内存空间，提高内存利用率

### 4. 垃圾回收的常见方法

> 根据判断对象是否存活的方法，可以简单将 `GC`算法分为“引用计数式”垃圾回收和“追踪回收式”垃圾回收。前者根据每个对象的引用计数器是否为 `0`来判断该对象是否为未引用的垃圾对象，后者先判断哪些对象存活，然后将其余的所有对象作为垃圾进行回收。追踪回收本身包括标记-清除 `Mark-Sweep`、标记-复制 `Mark-Copy`和标记-整理 `Mark-Compact`三种回收算法。

#### 1. 引用计数

引用计数`Reference counting`会为每个对象维护一个计数器，当该对象被其他对象引用时加一，引用失效时减一，当引用次数归零后即可回收对象。使用这类`GC`方法的语言包括`python`、`php`、`objective-C`和`C++`标准库中的`std::shared_ptr`等。

##### 引用技术的优点：

- 原理和实现都比较简单
- 回收的即时性：当对象的引用技术为0时立即回收，不像其他GC机制需要等待特定时机再回收，提高了内存的利用率
- 不需要暂停应用即可完成回收

##### 缺点

- 无法解决循环引用的回收问题：当`ObjA`引用了`ObjB`，`ObjB`也引用`ObjA`时，这两个对象的引用次数使用大于`0`，从而占用的内存无法被回收
- 时间和空间成本较高：一方面是因为每个对象需要额外的空间存储引用计数器变量，另一方面是在栈上的赋值时修改引用次数时间成本较高（原本只需要修改寄存器中的值，现在计数器需要不断更新因此不是只读的，需要额外的原子操作来保证线程安全）

- 引用计数是一种摊销算法，会将内存的回收分摊到整个程序的运行过程，但是当销毁一个很大的树形结构时无法保证响应时间

#### 2. 追踪基础：可达性分析算法

尽管前面提到的三种追踪式垃圾回收算法实现起来各不相同，但是第一步都是通过可达性分析算法标记`Mark`对象是否“可达”。一般可到达的对象主要包括两类：

- GC Root对象：包括全局对象、栈上的对象（函数参数与内部变量）
- 与GC Root对象通过引用链Reference Chain相连的对象

对于“不可达”的对象，我们可以认为该对象为垃圾对象并回收对应的内存空间。

![image-20230619215746210](E:\Typora picture\image-20230619215746210.png)

可达性算法中判断对象是否“可达”依赖于“引用”的定义，`java`中的引用从强到弱可分为四类，不同的引用类型可以满足多样化的场景：

- 强引用`Strong Reference`：使用`Object obj = new Object()`定义的引用，这类对象无论在什么情况下都不会被垃圾回收机制清理掉
- 软引用`Soft Reference`：用于描述有用但非必需的对象，只有在内存不足的时候才会回收该对象，适合实现内存敏感的高速缓存（网页缓存和图片缓存等）；软引用可以和引用队列`ReferenceQueue`一起使用，当软引用所引用的对象被回收时`JVM`会把这个软引用加入到与之关联的引用队列，`GC`线程会在抛出`OOM`错误前根据引用队列来回收长时间闲置不用的软引用对象
- 弱引用`Weak Reference`：用于描述非必需对象，在`JVM`进行垃圾回收时会直接回收被弱引用关联的对象，同软引用相比有更短的生命周期
- 虚引用`Phantom Reference`：一个对象与虚引用关联时在任何时候都可以被垃圾回收器回收，因此并不会影响该对象的生命周期，主要用于跟踪对象被`GC`回收的活动；虚引用必须和引用队列联合使用，当回收一个对象时如果发现它还有虚引用，就会在回收对象的内存之前将这个虚引用加入到与之关联的引用队列中，这样程序可以通过判断引用队列是否加入虚引用来判断被引用的对象是否将进行垃圾回收

![img](E:\Typora picture\12b1fef7af0bd34401cf41c646f1aae2.png)

同引用计数法相比，

##### 追踪式算法优点：

- 解决了循环引用对象的回收问题
- 占用空间更少

##### 缺点包括：

- 同引用计数相比无法立刻识别出垃圾对象，需要依赖`GC`线程
- 算法在标记时必须暂停整个程序，即`Stop The World, STW`，否则其他线程的代码会修改对象状态从而回收不该回收的对象

#### 3. 标记-清除算法

标记-清除`Mark-Sweep`算法是最基础的追踪式算法，分为“标记”和“清除”两个步骤：

- 标记：记录需要回收的垃圾对象
- 清除：在标记完成后回收垃圾对象的内存空间

![img](E:\Typora picture\665c384683d758602dd5ec82f4c4af14.png)

##### 优点包括：

- 算法吞吐量较高，即运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）较高
- 空间利用率高：同标记-复制相比不需要额外空间复制对象，也不需要像引用计数算法为每个对象设置引用计数器

##### 缺点包括：

- 清除后会产生大量的内存碎片空间，导致程序在运行时可能没法为较大的对象分配内存空间，导致提前进行下一次垃圾回收

#### 4. 标记-复制算法

标记-复制`Mark-Copy`算法将内存分成大小相同的两块，当某一块的内存使用完了之后就将使用中的对象挨个复制到另一块内存中，最后将当前内存恢复未使用的状态。

![image-20230619221130780](E:\Typora picture\image-20230619221130780.png)

##### 优点包括：

- 标记-清除法需要在清除阶段对大量垃圾对象进行扫描，标记-复制则只需要从`GC Root`对象出发，将“可到达”的对象复制到另一块内存后直接清理当前这块的内存，因此提升了垃圾回收的效率
- 解决了内存碎片化的问题，防止分配较大连续空间时的提前`GC`问题

##### 缺点包括：

- 同标记-清除法相比，在“可达”对象占比较高的情况下有复制对象的开销
- 内存利用率较低，相当于可利用的内存仅有一半

#### 5. 标记-整理算法

标记-整理`Mark-Compact`算法综合了标记-清除法和标记-复制法的优势，既不会产生内存碎片化的问题，也不会有一半内存空间浪费的问题。该方法首先标记出所有“可达”的对象，然后将存活的对象移动到内存空间的一端，最后清理掉端边界以外的内存。

![image-20230619222240189](E:\Typora picture\image-20230619222240189.png)

##### 优点包括：

- 避免了内存碎片化的问题
- 在对象存活率较高的情况下，标记-整理算法由于不需要复制对象效率更高，因此更加适合老年代算法

##### 缺点包括：

- 整理过程较为复杂，需要多次遍历内存导致`STW`时间比标记-清除算法更长

#### 6. 三色标记法

前面提到的“标记”类算法都有一个共同的瑕疵，即在进行垃圾回收的时候会暂停整个程序（`STW`问题）。三色标记法是对“标记”阶段的改进，在不暂停程序的情况下即可完成对象的可达性分析。`GC`线程将所有对象分为三类：

- 白色：未搜索的对象，在回收周期开始时所有对象都是白色，在回收周期结束时所有的白色都是垃圾对象
- 灰色：正在搜索的对象，但是对象身上还有一个或多个引用没有扫描
- 黑色：已搜索完的对象，所有的引用已经被扫描完

三色标记法属于增量式`GC`算法，回收器首先将所有的对象着色成白色，然后从`GC Root`出发，逐步把所有“可达”的对象变成灰色再到黑色，最终所有的白色对象即是“不可达”对象。

具体的实现如下：

- 初始时所有对象都是白色对象
- 从`GC Root`对象出发，扫描所有可达对象并标记为灰色，放入待处理队列
- 从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列
- 重复上一步骤，直到灰色对象队列为空
- 此时所有剩下的白色对象就是垃圾对象

##### 优点：

- 不需要暂停整个程序进行垃圾回收

##### 缺点：

- 如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致程序中的垃圾对象越来越多而无法及时收集
- 线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量

### 5. 读写屏障技术

#### 1. 三色标记法的并发性问题

假设三色标记法执行前，包含如下对象：

![image-20230619231057396](E:\Typora picture\image-20230619231057396.png)

则三色标记法的具体执行过程如下：

![image-20230619231125807](E:\Typora picture\image-20230619231125807.png)

上述三色标记执行过后堆内存中白色对象（只有`D`）会被当做垃圾对象清理掉，如果用户在标记执行过程中建立了从`A`对象到`D`对象的引用，那么会导致后续对`D`的访问出错。这种没有指向合法地址的指针一般被称为“野指针”，会造成严重的程序错误。

![image-20230619231705596](E:\Typora picture\image-20230619231705596.png)

#### 2. 并发问题原因及解决思路

假设三色标记法和用户程序并发执行，那么下列两个条件**同时满足**就可能出现错误回收非垃圾对象的问题：

- 条件1：某一黑色对象引用白色对象
- 条件2：对于某个白色对象，所有和它存在可达关系的灰色对象丢失了访问它的可达路径

简单证明一下：如果条件1不满足，那么任何不该被回收的白色对象都能和至少一个灰色对象存在“可达”路径，因此不会有白色对象被遗漏；如果条件2不满足，那么对于某一个白色对象，即使它被黑色对象引用，但至少存在一个和它存在可达关系的灰色对象，因此这个白色对象也不会被回收。

> 一句话总结即是：在三色标记法执行的某个特定时机，只要存在未经访问的能够到达白色对象的可达路径，就可以令黑色对象引用白色对象，反正该白色对象在后面标记中会被识别为“可达”对象从而不会被错误回收。

一种最简单解决三色标记并发问题的方法是停止所有的赋值器线程，保证标记过程不受干扰，即垃圾回收器中常提到的`STW, stop the world`方法。另外一种思路就是使用赋值器屏障技术使得赋值器在进行指针写操作时同步垃圾回收器，保证不破坏弱三色不变性（见下文）。

#### 3. 读写屏障技术

> 屏障技术：给代码操作内存的顺序添加一些限制，即在内存屏障前执行的动作必须先于在你内存屏障后执行的动作。

使用屏障技术可以使得用户程序和三色标记过程并发执行，我们只需要达成下列任意一种三色不变性：

- 强三色不变性：黑色对象永远不会指向白色对象
- 弱三色不变性：黑色对象指向的白色对象至少包含一条由灰色对象经过白色对象的可达路径

`GC`中使用的内存读写屏障技术指的是编译器会在编译期间生成一段代码，该代码在运行期间用户读取、创建或更新对象指针时会拦截内存读写操作，相当于一个`hook`调用，根据`hook`时机不同可分为不同的屏障技术。由于读屏障`Read barrier`技术需要在读操作中插入代码片段从而影响用户程序性能，所以一般使用写屏障技术来保证三色标记的稳健性。

> 我们讲内存屏障技术解决了三色标记法的 `STW`缺点，并不是指消除了所有的赋值器挂起问题。需要分清楚 `STW`方法是全局性的赋值器挂起而内存屏障技术是局部的赋值器挂起。

![image-20230619233016606](E:\Typora picture\image-20230619233016606.png)

#### 4. Dijkstra插入写屏障

`Dijkstra`插入写屏障避免了前面提到的条件1，即防止黑色对象指向白色对象。

```c
// 添加下游对象的函数, 当前下游对象slot, 新下游对象ptr
func DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {// 1) 将新下游对象标记为灰色shade(ptr)// 2) 当前下游对象slot = 新下游对象ptr*slot = ptr
}

// 场景一：A之前没有下游, 新添加一个下游对象B, B被标记为灰色
A.DijkstraWritePointer(nil, B)
// 场景二：A将下游对象C更换为B, B被标记为灰色
A.DijkstraWritePointer(C, B)
```

一个对象可以存储在内存中的“栈”或者“堆”，由于“栈”空间容量小且要求相应速度较高，因此“插入写屏障”不适合用于“栈”空间。在“插入写屏障”保护下的三色标记法执行例子如下：

![image-20230619235742308](E:\Typora picture\image-20230619235742308.png)

![image-20230619235903246](E:\Typora picture\image-20230619235903246.png)

![image-20230620000135961](E:\Typora picture\image-20230620000135961.png)

![image-20230620000758945](E:\Typora picture\image-20230620000758945.png)

![image-20230620001041041](E:\Typora picture\image-20230620001041041.png)

![image-20230620001702980](E:\Typora picture\image-20230620001702980.png)

![image-20230620001849510](E:\Typora picture\image-20230620001849510.png)

![image-20230620001932953](E:\Typora picture\image-20230620001932953.png)

![image-20230620002024332](E:\Typora picture\image-20230620002024332.png)

- 第一步：垃圾回收之前将所有的对象标记为白色
- 第二步：遍历`GC Root Set`，将可达对象标记为灰色
- 第三步：遍历灰色对象列表，将可达的对象从白色标记为灰色；将遍历完的灰色对象标记为黑色
- 第四步：在三色标记过程中用户程序令栈区对象A指向对象H，令堆区对象E指向对象I，由于对象E在堆区从而触发插入写屏障并将黑色对象E指向的白色对象I标记为灰色，栈区对象A不触发
- 第五步：继续三色标记直至灰色对象队列为空
- 第六步：由于栈区对象没有启动插入写屏障，因此栈上可能存在白色对象被引用的情况（上图中对应对象H），因此在回收白色对象前在`STW`保护下重新扫描一次栈空间
- 第七步：在`STW`保护下对栈空间一次性进行三色标记，直到灰色对象队列为空
- 第八步：结束`STW`
- 第九步：最后将栈空间和堆空间的白色垃圾对象进行回收

尽管`Dijkstra`插入写屏障可以实现垃圾回收和用户程序的并发执行，但是它存在两个缺点。**一方面它是一种比较保守的垃圾回收方法，把有可能存活的对象都标记成灰色了以满足“强三色不变性”。**以下图为例，用户程序`Mutator`将对象A原本指向B对象的指针改成指向C对象，尽管在修改后B对象已经是一个垃圾对象，但是它在本轮垃圾回收过程中不会被回收。

![image-20230620010649433](E:\Typora picture\image-20230620010649433.png)

另外一个缺点在于栈上的对象也是根对象，`Dijkstra`插入写屏障要么在用户程序执行内存写操作时为栈上对象插入写屏障，要么在一轮三色标记完成后使用`STW`重新对栈上的对象进行三色标记。前者会降低栈空间的响应速度，后者会暂停用户程序。

#### 5. Yuasa删除写屏障

`Yuasa`删除写屏障避免了前面提到的条件2，防止丢失灰色对象到白色对象的可达路径。当用户程序执行`*slot = ptr`时（即令`slot`指向了`ptr`），我们会将当前下游对象`*slot`标记为灰色。一句话解释就是当删除对象`A`指向对象`B`的指针时，那么将被删除的对象标记为灰色。

```
// 添加下游对象的函数, 当前下游对象slot, 新下游对象ptr
func YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {// 1) 将当前下游对象标记为灰色shade(*slot)// 2) 当前下游对象slot = 新下游对象ptr*slot = ptr
}

// 场景一：B被A删除, 将B标记为灰色
A.添加下游对象(B, nil)
// 场景二：B被A删除, 将B标记为灰色
A.添加下游对象(B, C)
```

![image-20230620011133595](E:\Typora picture\image-20230620011133595.png)

![image-20230620011240263](E:\Typora picture\image-20230620011240263.png)

![image-20230620011438179](E:\Typora picture\image-20230620011438179.png)

![image-20230620011646497](E:\Typora picture\image-20230620011646497.png)

![image-20230620011742977](E:\Typora picture\image-20230620011742977.png)

![image-20230620011817276](E:\Typora picture\image-20230620011817276.png)

- 第一步：将所有对象标记为白色
- 第二步：遍历`GC Root Set`将可达对象设为灰色
- 第三步：如果用户程序令灰色对象`A`删除了对白色对象`D`的引用，如果这时候不触发删除写屏障，那么对象`D`、`B`和`C`直到本轮垃圾回收结束都会是白色对象。因此需要触发删除写屏障，将对象`D`标记为灰色。
- 第四步：遍历灰色对象队列，将可达的白色对象标记为灰色，遍历完的灰色对象标记为黑色
- 第五步：继续进行三色标记，直到灰色对象队列为空
- 第六步：清除所有的白色对象

下图简单绘制了`Yuasa`删除写屏障是如何保证用户程序`Mutator`和垃圾回收器`Collector`的并发执行的：

- 第二步中`Mutator`将对象`A`原本指向对象`B`的指针指向`C`，由于对象`B`本身就是灰色的，因此不需要对它重新着色
- 第三步中`Mutator`删除了对象`B`指向对象`C`的指针，删除写屏障将下游对象`C`标记为灰色



![img](E:\Typora picture\6eeb50d5dd2e38a5e98a31a86a801534.png)



`Yuasa`删除写屏障和`Dijkstra`插入写屏障相比优点在于不需要在一轮三色标记后对栈空间上的对象进行重新扫描，缺点在于`Collector`会悲观地认为所有被删除的对象都可能被黑色对象引用，比如上图中第三步`Mutator`删除了对象`B`指向对象`C`的指针，如果此时还有一个单独的对象`E`指向`C`，那么本该被删除的对象`E`却可以在本轮垃圾回收中存活。

#### ==**6. 混合写屏障**==

##### **==6.1 引入混合写屏障的原因==**

在`go v1.8`引入混合写屏障`hybrid write barrier`之前，由于`GC Root`对象包括了栈对象，如果运行时在所有`GC Root`对象上开启插入写屏障意味着需要在数量庞大的`Goroutine`的栈上都开启`Dijkstra`写屏障从而严重影响用户程序的性能。之前的做法是`Mark`阶段（`golang`垃圾回收使用的是标记-清除法）结束后暂停整个程序，对栈上对象重新进行三色标记法。

> 如果Goroutine较多的话，对栈对象re-scan这一步需要耗费10~1000ms

回顾一下之前提到的两种写屏障的劣势：

- `Dijkstra`插入写屏障：一轮标记结束后需要`STW`重新扫描栈上对象
- `Yuasa`删除写屏障：回收精度低，在垃圾回收开始前使用`STW`扫描所有`GC Root`对象形成初始快照，用户程序`Mutator`从灰色/白色对象中删除白色指针时会将下游对象标记为灰色，相当于保护了所有初始快照中的白色对象不被删除

##### **==6.2 混合写屏障的实现==**

```c
// 添加下游对象的函数, 当前下游对象slot, 新下游对象ptr
func HybridWritePointerSimple(slot *unsafe.Pointer, ptr unsafe.Pointer) {// 1) 将被删除的下游对象标记为灰色shade(*slot)// 2) 将新下游对象标记为灰色shade(ptr)// 3) 当前下游对象slot = 新下游对象ptr*slot = ptr
}
```

> 注意：混合写屏障也是仅在堆空间启动的，防止降低栈空间的运行效率

混合写屏障逻辑如下：

- `GC`开始时将栈上所有对象标记为黑色，无须`STW`
- `GC`期间在栈上创建的新对象均标记为黑色
- 将被删除的下游对象标记为灰色
- 将被添加的下游对象标记为灰色

##### **==6.3 具体场景的实现==**

`GC`开始阶段会将所有栈空间可达对象都标记为黑色：![img](E:\Typora picture\1c34534b9c47b1094debf8164336eb55.png)



场景一：某个对象从堆对象的下游变成栈对象的下游，这种情况下标记该对象为灰色，该对象就不会被错误地回收

![img](E:\Typora picture\38bc32961ac6497ac9e142809cdb72fd.png)



场景二：某个对象从一个栈对象的下游变成另一个对象的下游，由于对象全都在栈空间对象的可达对象中，因此混合写屏障不会对这些对象着色。

![img](E:\Typora picture\6c1b102f5d877686edf2a53343a02e2a.png)



场景三：某个对象从一个堆对象的下游变成另一个堆对象的下游，比如下图中对象G从F的下游移动到Y的下游，为了避免对象`G`被错误回收，我们需要将其标记为灰色

![img](E:\Typora picture\e9d602f1b177e2e582ed44a21db31229.png)



场景四：某个对象从栈对象的下游变成堆对象的下游，对于栈空间对象不触发写屏障，但是对于被删除的堆空间对象`G`需要标记成灰色以保护它和它的下游对象不被错误删除

![img](E:\Typora picture\ae2165d756cf8c3320c258a28d292b75.png)



### **8. 分代收集算法**

前面提到追踪式垃圾回收算法一个显著的问题是会频繁扫描生命周期较长的对象，而内存分配存在一个`most object die young`（绝大部分对象的生命周期都很短）的事实，因此有必要将对象按照生命周期的长度划分到堆`heap`上的两个甚至多个区域。对于新生代区域的扫描频率应该高于老年代区域。

### **8.1 分代收集算法的三个假设**

- 弱分代假说：大多数对象的生命周期都很短
- 强分代假说：多轮垃圾回收都没清理掉的对象往往不容易死亡
- 跨代引用假说：跨代引用和同代引用相比仅占一小部分

### **8.2 新生代分区和老年代分区**

分代收集算法会将对象按照生命周期的长短划分到不同的分区。对于生命周期短的新生代区域，每次回收仅需要考虑如何保留少量的存活对象，因此可以采用标记-复制算法完成`GC`；对于生命周期长的老年代区域，可以通过减少垃圾回收的频率来提升效率，同时由于对象存活率高没有额外的空间用于复制，因此一般使用标记-清除算法或者标记-整理算法。

> 分代收集算法首先会根据对象的生命周期将内存划分为 `Young`和 `Old`两块大区域。由于新生代中的对象生命周期较短（每次回收约 `98%`的对象是垃圾对象），再加上新生代采用标记-复制法需要两块内存交替使用， `Young`区为了节省复制算法的内存代价又划分成 `Eden`、 `Survivor0`和 `Survivor1`三个分区（内存分配比例为 `8:1:1`）。另外，我们没法保证 `Young`区每次回收都仅有 `10%`不到的对象存活，因此当 `Survivor`区空间不够时需要放到 `Old`区，而且大对象需要直接进 `Old`区。



![img](E:\Typora picture\247ea13b01610ec1f4ac83229e9bba1a.png)



由于堆分为`Young`和`Old`两个分区，因此垃圾回收也根据回收的分区不同划分为新生代回收`Minor GC`和老年代回收`Major GC`。

### **8.3 对象的分配策略**

- 对象优先在`Yonug`上的`Eden`区域分配
- 大对象直接进入`Old`区：主要是因为我们没法保证`Young`区每次回收都仅有`10%`不到的对象存活，因此标记-复制法下`Survivor`难以回收较大的对象
- 新生代中生命周期较长的对象在`Survivor`区每熬过因此`Minor GC`就会增加一岁，年龄增加到一定阈值时就进入老年代

### **8.4 分代算法的大体流程**

假设一开始`Young`和`Old`区都是空的，流程如下：

1. 新分配的对象优先存放在`Eden`区（大对象直接进入`Old`区）
2. `Eden`区满了之后开始进行`Minor GC`，将`Eden`中存活的对象移动到`Survivor0`区，直接清空`Eden`区
3. `Eden`区第二次满了之后进行`Minor GC`，将`Eden`和`Survivor0`中存活的对象复制到`Survivor1`区，清空`Eden`和`Survivor0`区
4. 若干轮`Minor GC`过后，此时新生代中生命周期较长的对象熬过了一定次数的`Minor GC`晋升成老年代移动到`Old`区，某轮`Minor GC`存活率较高`Survivor`区空间不足时也会将存活对象放到`Old`区
5. 当`Old`区满了之后进行`Major GC`

## **增量和并发式垃圾回收**



![img](E:\Typora picture\f6f04c7195d462321ee11b8150f26593.png)



前面提到传统的垃圾回收算法都有`STW`的弊端，即需要在执行垃圾回收过程中需要抢占`CPU`，这会暂停所有的用户程序。这有两个弊端：

- 通常`GC`任务都比较繁重，长时间暂停用户程序会影响程序的响应速度，这对于实时性要求较高的程序是致命的缺点
- 对于多核计算机而言，抢占`CPU`进行垃圾回收会造成计算资源浪费

> 三色标记法结合读写屏障技术使得垃圾回收器 `Collector`避免了 `STW`，因此后续提到的增量式垃圾回收和并发式垃圾回收都是基于三色标记法和读写屏障技术的。为了保证三色不变性，我们需要在垃圾回收前打开写屏障，在本轮垃圾回收过程中用户所有对内存的写操作都需要被写屏障拦截。

### **1. 增量式垃圾回收**



![img](E:\Typora picture\114d5bb9791d0a3b9dbc0bcad63df22b.png)



增量式垃圾回收过程图如上所示，同`STW`垃圾回收过程相比：

- 优势：将垃圾回收时间分摊开，避免了程序的长时间暂停，防止影响程序的实时性
- 劣势：一方面引入了内存写屏障技术，需要额外的计算开销；另一方面由于写屏障技术的保守性导致有一些垃圾对象没有被回收，会增加一轮垃圾回收的总时长

### **2. 并发式垃圾回收**



![img](E:\Typora picture\9e3feb6092b7911a9721d58cb81b1b70.png)



并发式垃圾回收允许垃圾回收器`collector`和用户程序`mutator`同时执行，但仍然有一些阶段需要暂停用户程序。并发式的垃圾回收机制在一定程序上利用了多核计算机的优势并减少了对用户程序的干扰，不过依然无法摆脱读写屏障的额外计算开销和增加一轮垃圾回收总时长的问题。

## **Golang GC如何扫描对象[见Reference14]**

Golang扫描对象可以分为三部分：

- 编译阶段：对静态类型做好标记准备
- 运行阶段：赋值器分配内存时，根据编译阶段的type为对象内存对应的指针设置bitmap
- 扫描阶段：根据指针的bitmap进行扫描

### **1. 编译阶段**

### **1.1 Golang结构体对齐规则**

Golang结构体对齐规则包括两部分：

- 长度对齐
- 地址对齐

### **1.2 长度对齐**

长度对齐指的是结构体的长度至少是内部最长的基础字段的整数倍。比如下面这个结构体内存占用为16个字节，因为TestStruct整体要和内部最长的基础字段ptr（8字节的uintptr类型）对齐。

```
type TestStruct struct {ptr   uintptr  // 8字节int1  uint32   // 4字节int2  uint8    // 1字节
}
```

### **1.3 地址对齐**

字段的地址偏移是自身长度的整数倍，仍然以TestStruct为例，令第二个元素为1个字节大小：

```
// 假设new一个TestStruct结构体的地址是x, 则各字段的地址如下
// ptr: a + 0
// int1: a + 8
// int2: a + 8 + 4
type TestStruct struct {ptr   uintptr  // 8字节int1  uint8    // 1字节int2  uint32   // 4字节
}
```

> int1和int2之间填充了一些没使用到的内存空间，进而实现了地址对齐。

### **1.4 指针位标记**

golang的所有类型都对应一个_type结构：

```
// Needs to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize,
// ../cmd/compile/internal/gc/reflect.go:/^func.dcommontype and
// ../reflect/type.go:/^type.rtype.
type _type struct {size       uintptrptrdata    uintptr // size of memory prefix holding all pointershash       uint32tflag      tflagalign      uint8fieldalign uint8kind       uint8alg        *typeAlg// gcdata stores the GC type data for the garbage collector.// If the KindGCProg bit is set in kind, gcdata is a GC program.// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.gcdata    *bytestr       nameOffptrToThis typeOff
}
```

比如说我们定义一个struct如下：

```
type TestStruct struct {ptr   uintptrint1  uint8pint1 *uint8int2  uint32pint2 *uint64int3  uint64
}
```

- size：类型长度，上面这个结构体的长度48个字节
- ptrdata：指针截止的长度位置，由于最后一个指针是`pint2`，因此包含指针的字段截止到40字节的位置
- kind：类型，自定义struct类型的kind为25
- gcdata：byte数组（*byte类型），表示指针的bitmap。比如当gcdata等于20（二进制00010100，从低位到高位就是00101000，其中每个bit表示一个指针大小（8字节）的内存，第3个bit和第5个bit为1表示第三个和第五个字段是指针类型）。

> 第一个类型uintptr在指针的bitmap是不会标记成指针类型的，用这个存储指针是无法保护对象的（扫描的时候uintptr指向的对象不会被扫描）。

### **2. 运行期内存分配**

golang在运行分配完内存后会调用函数`heapBitsSetType`，这个函数及其复杂，但是主要逻辑是根据编译期间对每个struct生成的type结构，用一个bitmap记录下来分配的内存块中哪些位置是指针。

### **3. 运行扫描阶段**

- 扫描阶段从markroot开始，以栈对象、全局变量和寄存器对象作为gc root，创建一个有向引用图并将根对象添加到队列中
- 新起一个异步goroutine执行gcDrain函数，从队列里消费并扫描对象
