# 7. new 和 make

## 指针地址和指针类型

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用`&`字符放在变量前面对变量进行“取地址”操作。 Go语言中的==值类型（int、float、bool、string、array、struct）都有对应的指针类型==，如：`*int`、`*int64`、`*string`等。

取变量指针的语法如下：

```go
ptr := &v // v 的类型为T
```

其中：

- v:代表被取地址的变量，类型为`T`
- ptr:用于接收地址的变量，ptr的类型就为`*T`，称做T的指针类型。*代表指针。

`b := &a`的图示：

![取变量地址图示](E:\Typora picture\ptr.png)

## 指针取值

在对普通变量使用&操作符取地址后会获得这个变量的指针，然后==可以对指针使用*操作，也就是指针取值==，代码如下。

```go
func main() {
	//指针取值
	a := 10
	b := &a // 取变量a的地址，将指针保存到b中
	fmt.Printf("type of b:%T\n", b)
	c := *b // 指针取值（根据指针去内存取值）
	fmt.Printf("type of c:%T\n", c)
	fmt.Printf("value of c:%v\n", c)
}
```

输出如下：

```go
type of b:*int
type of c:int
value of c:10
```

**总结：** ==取地址操作符`&`和取值操作符`*`是一对互补操作符，`&`取出地址，`*`根据地址取出地址指向的值。==

变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：

- 对变量进行取地址（&）操作，可以获得这个变量的指针变量。
- 指针变量的值是指针地址。
- 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。

## ==new 和 make==

```go
func main() {
	var a *int
	*a = 100
	fmt.Println(*a)

	var b map[string]int
	b["沙河娜扎"] = 100
	fmt.Println(b)
}
```

执行上面的代码会引发panic，为什么呢？

在Go语言中

- **对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。**
- **对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间**。

要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。

### new

new是一个内置的函数，

```go
func new(Type) *Type
```

其中，

- Type表示类型，new函数只接受一个参数，这个参数是一个类型
- *Type表示类型指针，**new函数返回一个指向该类型内存地址的指针。**

new函数不太常用，**==使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值==**。举个例子：

```go
func main() {
	a := new(int)
	b := new(bool)
	fmt.Printf("%T\n", a) // *int
	fmt.Printf("%T\n", b) // *bool
	fmt.Println(*a)       // 0
	fmt.Println(*b)       // false
}	
```

本节开始的示例代码中`var a *int`只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：

```go
func main() {
	var a *int
	a = new(int)
	*a = 10
	fmt.Println(*a)
}
```

我们通常会使用 var 来定义变量，而非使用 new。因为 **var 在定义变量时，会同时进行变量的声明和零值初始化**。而 **new 只是进行了零值初始化，并没有进行变量的声明**，因此**需要使用赋值语句将其赋给一个变量**。同时，**使用 new 分配的内存空间是默认零值的，而使用 make 分配的内存空间是经过初始化的。**

### make

make也是用于内存分配的，区别于new，它**==只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了==**。make函数的函数签名如下：

```go
func make(t Type, size ...IntegerType) Type
```

make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。

本节开始的示例中`var b map[string]int`只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：

```go
func main() {
	var b map[string]int
	b = make(map[string]int, 10)
	b["沙河娜扎"] = 100
	fmt.Println(b)
}
```

### new与make的区别

#### 共同点

1. 二者都是用来做内存分配的，都将内存分配到堆(heap)上；

#### 不同点

1. ==make只用于slice、map以及channel的初始化==；==new用于类型的内存分配，并且内存对应的值为类型零值==。
2. make返回的还是这三个引用类型本身，new返回的是指向类型的指针。
3. make分配空间后会进行初始化，new分配的空间被清零，并没有初始化内存。



> 这是因为在 Golang 中，除了一些基本类型之外，大部分的变量都是引用类型，即变量存储的是一个指向实际数据的地址。而在栈上分配变量时，会随着函数的执行完毕而自动回收，但在堆上分配变量时，需要手动进行垃圾回收。
>
> 因此，在 Golang 中，新的变量通常都会在堆上被分配，并且等待垃圾回收器进行回收。同时，对于小对象或临时对象，也可能会被分配到栈上。
>
> 需要注意的是，在 Golang 中，无论是栈还是堆，都是由运行时(runtime)负责分配和管理的，并不需要程序员自己管理内存。这也是 Golang 作为一门高级语言的一个特点。

> 零值是指变量在未进行显式初始化时自动获得的值。在 Golang 中，所有变量都有默认的零值，它们如下：
>
> - 数值类型（int、float、complex 等）：0
> - bool 类型：false
> - string 类型：""
> - 指针类型：nil
>
> 对于结构体和数组等复合类型，它们的零值则是所有成员或元素的零值。
>
> 
>
> 与零值不同，初始化是指给变量赋予一个明确的初始值。在 Golang 中，make 用于初始化切片、映射和通道等引用类型，而 new 则只是分配了一块内存，并没有进行初始化操作。在 Golang 中，切片、映射和通道等引用类型在创建时必须先进行初始化操作，否则会出现 panic 异常。因此，使用 make 进行初始化是常见的做法，而使用 new 分配内存空间后，需要手动进行初始化操作。