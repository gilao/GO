# 9. 进程、线程、协程

进程 = 火车；线程 = 车厢

- ==线程在进程下进行==（单纯的车厢无法运行）
- ==一个进程可以包含多个线程== （一辆火车可以有多个车厢）
- ==同一进程下不同线程间数据很易共享==（A车厢换到B车厢很容易）
- ==进程要比线程消耗更多的计算机资源==（采用多列火车相比多个车厢更耗资源）
- ==进程间不会相互影响，一个线程挂掉将导致整个进程挂掉==（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- ==进程可以拓展到多机，进程最多适合多核==（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- ==进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。==（比如火车上的洗手间）－"互斥锁"
- ==进程使用的内存地址可以限定使用量==（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”




## 进程

进度是资源分配的最小单位；进程是应用程序的启动实例，**进程拥有代码和打开的文件资源，数据资源，独立的内存空间**

==系统是由一个个进程组成的==，**包括文本区，数据区和堆栈区**。进程的创建和销毁都==比较消耗资源和时间==。进程是==抢占式的==争夺CPU的资源，**==单核CPU在同一时刻只能有一个进程在执行。==**

## 线程

**线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有更多的子线程，线程拥有自己栈空间；**

对操作系统而言，==线程是最小的执行单元==，==进程是最小的资源管理单元==，无论是进程还是线程，**都是由操作系统所管理的**；

线程是**==CPU调度的最小单位==**，线程属于进程，它**==共享进程的整个内存空间==**。==**多线程是不安全的，进程内的一个线程崩溃会导致整个进程崩溃。**==

## 协程

协程是一种**用户态**的**轻量级线程**，正如一个进程可以拥有多个线程一样，**一个线程可以拥有多个协程。**==协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。==这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。

**协程拥有自己的寄存器上下文和栈。**协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：
**协程能保留上一次调用时的状态（即所有局部状态的一个特定组合）**，每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

**协程：协程是属于线程的，协程的程序是在线程里面跑的。**

**协程是原子操作的，不存在代码执行一半，被终止的情况。**


协程的好处：

1. **无需线程上下文切换的开销**
2. **无需原子操作锁定及同步的开销**
3. **方便切换控制流，简化编程模型**

高并发+高扩展性+低成本：**一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。**


缺点：

1. ==无法利用多核资源：协程的本质是个单线程==,它不能同时将 单个CPU 的多个核用上,==协程需要和进程配合才能运行在多CPU上==.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
2. ==进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序==

## 进程、线程、协程的对比

1. 协程既不是进程也不是线程，**==协程仅仅是一个特殊的函数==**，协程它进程和进程不是一个维度的。
2. ==线程和进程都是同步机制==，==协程是异步机制==
3. ==线程是抢占式==，==协程是非抢占式，需要用户释放使用权切换到其他协程，同一时间只有一个协程拥有运行权==，相当于单线程的能力
4. **==一个进程可以包含多个线程，一个线程可以包含多个协程==**。
5. ==一个线程内==的多个协程虽然可以切换，但是==多个协程是串行执行==的，只能在一个线程内运行，没法利用CPU多核能力。
6. 协程与进程、线程一样，切换是存在上下文切换问题的。

|      | 调度               | 上下文切换   | 拥有资源                                 | 系统开销                                                     | 切换开销             |
| ---- | ------------------ | ------------ | ---------------------------------------- | ------------------------------------------------------------ | -------------------- |
| 进程 | 资源管理的基本单位 | 慢           | 拥有资源的独立单位                       | 创建或撤销==进程开销==**显著大于**创建或撤销==线程时的开销== | 进程==**大于**==线程 |
| 线程 | 程序执行的基本单位 | 比进程快的多 | 不拥有系统资源，可以访问隶属于进程的资源 |                                                              |                      |
| 协程 |                    |              |                                          |                                                              |                      |



上下文切换对比：

==(1)进程的切换者是操作系统，==切换时机是根据操作系统自己的切换策略，==用户是无感知的==。进程的==切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。==进程切换过程是由“用户态到内核态到用户态”的方式，==切换效率低==。

==(2)线程的切换者是操作系统==，切换时机是根据操作系统自己的切换策略，用户是无感知的。==线程的切换内容包括内核栈和硬件上下文==,线程==切换内容保存在内核栈中.==线程切换过程是由“用户态到内核态到用户态”，==切换效率中等==。因为==线程的调度是在内核态运行的，而线程中的代码是在用户态运行，因此线程切换会导致用户态与内核态的切换==

(4)==协程的切换者是用户==（**编程者或应用程序**），==切换时机是用户自己的程序所决定的==。==协程的切换内容是硬件上下文==，==切换内存保存在用户自己的变量（用户栈或堆）中==。协程的切换过程只有用户态，即没有陷入内核态，因此==切换效率高==。



| 上下文切换对比 | 切换者                   | 切换时机                           | 切换内容                        | 切换内容保存位置               | 切换过程                   | 切换效率 |
| -------------- | ------------------------ | ---------------------------------- | ------------------------------- | ------------------------------ | -------------------------- | -------- |
| 进程           | 操作系统                 | 操作系统自己的切换策略，用户无感知 | 页全局目录、 内核栈、硬件上下文 | 内存中                         | 用户态到内核态到用户态     | 低       |
| 线程           | 操作系统                 | 操作系统自己的切换策略，用户无感知 | 内核栈，硬件上下文              | 内核栈中                       | 用户态到内核态到用户态     | 中等     |
| 协程           | 用户（编程者或应用程序） | 用户自己的程序决定的               | 硬件上下文                      | 用户自己的变量中（用户栈或堆） | 只有用户态，没有陷入内核态 | 高       |



## **最佳实践** 

1. 线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。
2. 对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。
3. 所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

