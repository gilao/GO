# 3. 数组

数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是**数组大小不可变化。** 基本语法：

```go
var a [3]int
```

## 数组的定义

```go
var 数组变量名 [元素数量]T
```

比如：`var a [5]int`， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 `[5]int`和`[10]int`是不同的类型，无法比较，长度也算类型的一部分。

数组可以通过下标进行访问，下标是从`0`开始，最后一个元素下标是：`len-1`，**访问越界（下标在合法范围之外），则触发访问越界，会panic。**

## 数组的初始化

```go
// 初始化列表来设置数组元素的值

var testArray [3]int                        
//数组会初始化为int类型的零值

var numArray = [3]int{1, 2}                 
//使用指定的初始值完成初始化

var cityArray = [3]string{"北京", "上海", "深圳"} 
//使用指定的初始值完成初始化

//按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度

var testArray [3]int
var numArray = [...]int{1, 2}
var cityArray = [...]string{"北京", "上海", "深圳"}

// 使用指定索引值的方式来初始化数组
a := [...]int{1: 1, 3: 5}
```

## 数组的遍历

```go
func main() {
	var a = [...]string{"北京", "上海", "深圳"}
	// 方法1：for循环遍历
	for i := 0; i < len(a); i++ {
		fmt.Println(a[i])
	}

	// 方法2：for range遍历
	for index, value := range a {
		fmt.Println(index, value)
	}
}
```

## 多维数组

### 二维数组的定义

```go
func main() {
	a := [3][2]string{
		{"北京", "上海"},
		{"广州", "深圳"},
		{"成都", "重庆"},
	}
	fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
	fmt.Println(a[2][1]) //支持索引取值:重庆
}
```

### 二维数组的遍历

```go
func main() {
	a := [3][2]string{
		{"北京", "上海"},
		{"广州", "深圳"},
		{"成都", "重庆"},
	}
	for _, v1 := range a {
		for _, v2 := range v1 {
			fmt.Printf("%s\t", v2)
		}
		fmt.Println()
	}
}
```

输出：

```bash
北京	上海	
广州	深圳	
成都	重庆	
```

**注意：** 多维数组**只有第一层**可以使用`...`来让编译器推导数组长度。例如：

```go
//支持的写法
a := [...][2]string{
	{"北京", "上海"},
	{"广州", "深圳"},
	{"成都", "重庆"},
}
//不支持多维数组的内层使用...
b := [3][...]string{
	{"北京", "上海"},
	{"广州", "深圳"},
	{"成都", "重庆"},
}
```

## 数组是值类型

**==数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。==**

```go
func modifyArray(x [3]int) {
	x[0] = 100
}

func modifyArray2(x [3][2]int) {
	x[2][0] = 100
}
func main() {
	a := [3]int{10, 20, 30}
	modifyArray(a) //在modify中修改的是a的副本x
	fmt.Println(a) //[10 20 30]
	b := [3][2]int{
		{1, 1},
		{1, 1},
		{1, 1},
	}
	modifyArray2(b) //在modify中修改的是b的副本x
	fmt.Println(b)  //[[1 1] [1 1] [1 1]]
}
```

**注意：**

1. 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。
2. `[n]*T`表示指针数组，`*[n]T`表示数组指针 。

在 Golang 中，**数组是一种值类型，这意味着当数组被复制时，实际上是复制整个数组的内容，而不只是复制它的引用。这也就意味着对于非常大的数组，复制操作会消耗相当大的内存和时间**。因此，在实际开发中，==通常使用切片(slice)来代替数组==，切片是一种便捷且灵活的数据结构，可以根据需要动态改变大小。