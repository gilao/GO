# 19. Golang的运行调度GMP[模型](https://blog.csdn.net/qq_33690342/article/details/115209536)

https://zhuanlan.zhihu.com/p/558260342

**G：**GO运行时==对goroutine的描述==，G中存放并发执行的代码入口地址、上下文、运行环境（关联的P和M）、运行栈等执行相关的信息。G的新建、休眠、恢复、停止都受到Go运行时的管理。

       GO运行时的监控线程会监控G的调度，G不会长久地阻塞系统线程，运行时的调度器会自动切换到其他G上运行。G新建或恢复时会添加到运行队列，等待M取出并运行。

**M：**==OS内核线程==，是操作系统层面调度和执行的实体。M仅负责执行，M不停地被唤醒或创建。然后执行。

**P：**Processer，代表M和G所需要的资源，是对资源的一种抽象管理，P不是一个段代码实体，而是一个管理的数据结构，P主要是降低M对G的复杂性，增加一个间接的控制层数据结构。P控制GO代码的并行度，它不是实体。

      P持有G的队列，P可以隔离调度，解除P和M的绑定就解除了M对一串G的调用。

G并不是执行体，而是存放并发执行体的元信息，包括并发执行的入口函数、堆栈、上下文等信息。G由于保存的是元信息，为了减少对象的分配和回收，G对象是可以复用，只需要将相关元信息初始化为新值即可。

M仅负责执行，M启动时进入运行时的管理代码，这段管理代码必须拿到P后，才能执行调度。

P的数目默认是CPU核心的数量。M和P的数目差不多，但运行时会根据当前的状态动态地创建M，M有一个最大值上限：10000；G与P是M:N的关系，M可以成千上万，远远大于N.

GMP模型设计思想：

<img src="E:\Typora picture\Untitled-2023-06-15-2344.png" alt="Untitled-2023-06-15-2344" style="zoom:200%;" />

![image-20230615222743100](E:\Typora picture\image-20230615222743100.png)